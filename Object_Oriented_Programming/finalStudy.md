## 8장
* inheritance : 기본 클래스(부모 클래스)의 속성, 기능을 파생 클래스(자식 클래스)에게 물려주는 것. 
  + 상속 선언 코드
  
<code>
  
   class Student : public Person{...};
  
</code>
  
  + 상속받은 파생 클래스 객체의 멤버 중, 재정의한 멤버가 아닌 상속받은 기존의 멤버는 "기본 클래스 멤버"라고 칭한다.
  + 그에 비해 새로 생긴 멤버는 "파생 클래스 멤버"라고 칭한다.

* Up Casting : 파생클래스의 포인터가 기본 클래스 포인터에 치환되는것. 
  + 포인터에 대한 포인터라고 할 수 있다.
  + ex) 부모 클래스의 포인터로 자식 클래스 중 기본 클래스 멤버만 접근하는 경우
  + 즉, 기본 클래스 멤버만 가능하다.
  
<code>
  
    ColorPoint cp; // 기본 클래스
    ColorPoint *pDer = &cp; // 파생 클래스
    Point* pBase = pDer; // 업캐스팅. pBase로는 cp의 public멤버만 접근할 수 있다.
  
</code>
  
* Down Casting : 기본 클래스의 포인터가 파생 클래스의 포인터에 치환되는 것.
  + 강제 타입 변환이 필요하다.

<code>

    ColorPoint cp;
    ColorPoint *pDer;
    Point* pBase = &cp; // 업캐스팅
    pDer = (ColorPoint *)pBase; // 다운캐스팅

</code>

* ★ 상속관계에 있는 생성자 호출 관계
  + C가 B를 상속받고, B가 A를 상속받는 경우 C, B, A 순서로 생성자가 호출된다.
  + 소멸자는 반대의 순서로 호출된다.
  + 컴파일러는 묵시적으로 기본 클래스의 기본 생성자를 호출하도록 한다.
  + 생성자가 명시적으로 기본 클래스의 생성자를 선택호출 할 수 있다.
  
<code>

    B(int x) : A(x+3) // A(int x) 생성자를 호출하게 된다.

</code>

* P30 예제 8-4
  + 1번 : Base의 private이므로
  + 2번 : Base를 상속하면서 private로 모든 접근제한자를 바꾸었기 때문
  + 3번 : Base를 상속하면서 private로 모든 접근제한자를 바꾸었기 때문
  + 4번 : Derived의 Private이므로
  + 5번 : Derived의 protected이므로

* 다중 상속은 참고로만 알고 있기
  + 상속받는 Basic class가 여러 개 있는 경우
  + 중복 상속의 문제가 발생할 수 있다. 즉, 아래의 경우 MP3, MobilePhone class가 Machine라는 class를 상속받는 경우 Machine를 2번 상속된다
  + 가상 상속으로 해결할 수 있다.
  + 자바에서는 이를 아예 허용하지 않는다.
  
<code>

    class MusicPhone : public MP3, public MobilePhone {
      public:
        void dial();
    };

</code>

## 9장
* 파생클래스에서 함수 재정의
* Upcasting 활용
  + Base에서 Derived를 파생하는 경우
  + /*ex.code*/
  + Derived *pDer;
  + Base* pBase = pDer; // Upcasting
  + pBase->f(); // Base의 f()를 호출. 즉, 오버라이딩을 해도 부모의 함수를 호출할 수 있다.
  
* Virtual Function : 동적 바인딩 지시어. 함수에 대한 호출 바인딩 실행 전까지 아무런 동작 X
  + 오버라이딩하면 업캐스팅해줘도 자녀 함수만 호출할 수 있다.
  
* ★ 함수 재정의와 오버라이딩 용어 정리
  + virtual(동적 바인딩) 사용하는 경우 : 오버라이딩
  + 정적 바인딩의 경우 : 함수 재정의
  + 자바는 무조건 동적 바인딩이 일어난다.

* P9 오버라이딩 활용하는 방법. 소공에서 쓸만할 듯

* 즉, 동적 바인딩이란 : 
  + 부모 클래스에 대한 포인터로 가상함수를 호출하는 경우, 
  + 객체 내에 오버라이딩한 자녀 클래스의 함수를 찾아서 자녀 클래스의 함수를 실행한다.
  + ★ 코드 암기

* 순수 가상 함수
* 추상 클래스 - 이게 순수 가상함수랑 엮어서 나올 듯

* 범위 지정 연산자는 원래 정적 바인딩을 지시한다.

* 동적 바인딩 : 런타임 시 누가 실행될 지 정하는 것

* P15 : 범위지정 연산자를 이용하여 기본 클래스의 가상 함수 호출 가능
  
* 소멸자를 virtual로 해서 오버라이딩 하는 경우 자식, 부모 소멸자가 모두 불린다. (자식 -> 부모 순서로)

* P18 오버로딩, 함수 재정의, 오버라이딩의 차이점
  + 오버라이딩 : Virtual을 사용. 동적 바인딩
  
* 순수 가상 함수 : 함수의 코드가 없고 선언만 있는 가상 멤버 함수
  + virtual void draw() = 0;
  
* 추상 클래스 : 최소한 하나의 순수 가상 함수를 가진 클래스.
  + 특징1 : 온전한 클래스가 아니므로 객체 생성 불가능
  + 특징2 : 추상 클래스의 포인터는 선언 가능
  + 추상 클래스의 상속 : 추상 클래스를 단순 상속하면 자동 추상 클래스
  + 추상 클래스의 구현 : 추상 클래스를 상속받아 순수 가상 함수를 오버라이딩
    - 파생 클래스는 추상 클래스가 아니다.

* P28 왼쪽 그림은 draw를 순수 가상 함수로 갖고 있으므로 Circle는 추상 클래스라 할 수 있다.
* p28 오른쪽 그림은 draw를 오버라이딩하여 순수 가상함수가 아니게 되므로 Circle는 추상 클래스라 할 수 없다.

* P29 Shape.h의 draw()가 순수 가상 함수이므로 Shape.cpp의 Shape.draw() 구현부는 존재하면 안된다.
  
## 10장
* 함수나 클래스를 일반화시켜 매개 변수 타입을 지정하여 틀에서 찍어내듯이 클래스 코드를 생산하는 기법
* P8 예제 코드
<code>

    template <class T>
    void myswap(T & a, T & b){
      T tmp;
      tmp = a;
      a = b;
      b = tmp;
    }

</code>
* 위와 같은 template 함수 myswap이 있을 때, 매개변수로 int, double, char 또는 그 외 무엇을 넣는지에 따라 T가 그것에 매칭되서 함수를 구체화하고 호출한다.
* 물론 매개변수 a, b에 다른 타입의 변수를 넣으면 에러가 발생한다!

* 템플릿 장단점
  + 장점 : 재사용 가능
  + 단점 : 포팅에 취약. 디버깅이 어려움
  
* P12,13 처럼 배열 원소도 매개변수로 사용할 수 있다.

* 제네릭 클래스 만들기 P16
  + MyStack이라는 이름의 class를 stack 역할을 하도록 직접 만드는 것.
  + 해당 class에는 push 등의 메소드 구현도 가능하다.
  + 제네릭 클래스에는 data type을 <int> 이런식으로 설정해줘야한다.
  + ★ P16 제네릭 클래스 선언, 구현, 및 호출 부분 문법 

* P17 실제 제네릭 클래스 생성해서 Stack 구현

* STL 컨테이너 종류 : vector, deque, list, set, map, stack, queue

* map, vector의 주요 멤버와 연산자 사용방법 정도는 예제 정도만큼만 알아두기

* vector : 가변길이 배열을 구현한 제네릭 클래스.
  + vector 함수 (P25)
  + iterator : 반복자. 컨테이너의 원소를 가리키는 포인터
  
* map : 키 값 쌍을 원소로 저장하는 컨테이너
  + map 함수 (P33)
  
* sort

* STL 구성
  + 컨테이너
  + iterator
  + 알고리즘

* STL 컨테이너 종류 : vector, deque, list, set, map, stack, queue

* map 컨테이너 : 키, 값 쌍을 우너소로 저장하는 제네릭 컨테이너
  + 키로 값을 검색 가능
  
* STL 알고리즘
  + sort(소팅 시작한 원소의 주소, 소팅 범위의 마지막 원소 다음 주소) 함수
  + P36 예시 코드
  
* iterator 변수 : 벡터 내의 원소를 탐색하는데 사용되는 변수.

* iterator, sort, 컨테이너 개념 이해하기 나올 듯..?★
